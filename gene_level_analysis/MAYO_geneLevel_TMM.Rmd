---
title: Covariate and differential expression analysis of MAYO reprocessed counts (with TMM normalisation)
author: Thanneer Perumal
editor_options:
  chunk_output_type: console
---
Date of analysis update: "`r date()`"

```{r libs, echo=FALSE, warning=FALSE, message=FALSE, include=FALSE, cache=FALSE}
## It is assumed your working directory is where this file

## Load required libraries
library(CovariateAnalysis) # get the package from devtools::install_github('th1vairam/CovariateAnalysis@dev')
library(data.table)
library(plyr)
library(tidyverse)
library(psych)

library(limma)
library(edgeR)
library(biomaRt)
library(RColorBrewer)
library(glmnet)

library(synapseClient)
library(githubr) # get the package from devtools::install_github('brian-bot/githubr')
library(knitr)

synapseLogin()

library(doParallel)
library(foreach)

cl = makeCluster(detectCores()-2)
registerDoParallel(cl)

options(xtable.type="html")

# Source modified utility functions from limma and sva package
source('../utilityFunctions/parallelDuplicateCorrelation.R')
source('../utilityFunctions/irwsva.build.R')
source('../utilityFunctions/f.pvalue.R')

knitr::opts_chunk$set(
  echo=FALSE,
  warning=FALSE,
  message=FALSE,
  error = FALSE,
  tidy = FALSE,
  cache = TRUE)
```

```{r synapse.parameters, include=FALSE}
# Synapse parameters
parentId = 'syn8672415'
activityName = 'Differential Expression Analysis';
activityDescription = 'Differential expression analysis of reprocessed RNASeq from MAYO samples';

# Github link
thisFileName <- 'MAYO_geneLevel_TMM.Rmd'
thisRepo <- getRepo(repository = "th1vairam/ampad-DiffExp", ref="branch", refName='geneLevelAnalysis')
thisFile <- getPermlink(repository = thisRepo, repositoryPath=paste0('gene_level_analysis/',thisFileName))
```

### Data download
Obtain count matrix and metadata from synapse
```{r download.data}
# Get reprocessed sample counts for temporal cortex
COUNT_TC_ID <- 'syn8690799';
ALL_USED_IDs <- COUNT_TC_ID
COUNT_TC <- synGet(COUNT_TC_ID)@filePath %>%
  read.table(header=T, sep='\t', check.names = F, row.names = 1)

# Get reprocessed sample counts for cerebellum
COUNT_CE_ID <- 'syn8690904';
ALL_USED_IDs[length(ALL_USED_IDs)+1] <- COUNT_CE_ID
COUNT_CE <- synGet(COUNT_CE_ID)@filePath %>%
  read.table(header=T, sep='\t', check.names = F, row.names = 1)

# Combine TCX and CBE counts
COUNT = cbind(COUNT_TC, COUNT_CE[rownames(COUNT_TC),])

# Convert rownames of counts from tracking id to ensemble gene id
tmp = data.frame(Gene.ID = rownames(COUNT)) %>%
  dplyr::mutate(ID = Gene.ID) %>%
  tidyr::separate(ID, c('ensembl_gene_id', 'position'), sep = '\\.')
rownames(tmp) = tmp$Gene.ID
rownames(COUNT) = tmp[rownames(COUNT), 'ensembl_gene_id']

# Get clinical metadata
METADATA_TC_ID <- 'syn3817650'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_TC_ID
METADATA_TC <- synGet(METADATA_TC_ID)@filePath %>%
  read.table(sep=',',header=T, stringsAsFactors=F) %>%
  tidyr::separate(ID, c('Donor_ID', 'Tissue'), sep = '_') %>%
  dplyr::mutate(ID = paste(Donor_ID, Tissue, sep = '_'))

# Get clinical metadata
METADATA_CE_ID <- 'syn5223705'
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA_CE_ID
METADATA_CE <- synGet(METADATA_CE_ID)@filePath %>%
  read.table(sep=',',header=T, stringsAsFactors=F) %>%
  tidyr::separate(SampleID, c('Donor_ID', 'Tissue')) %>%
  dplyr::mutate(ID = paste(Donor_ID, Tissue, sep = '_')) %>%
  dplyr::rename(Gender = Sex, FLOWCELL = Flowcell)

# Get picard metrics from synapse
METADATA.PICARD_CE_ID <- 'syn8698214';
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.PICARD_CE_ID
METADATA.PICARD_CE <- METADATA.PICARD_CE_ID %>%
  CovariateAnalysis::downloadFile() %>%
  dplyr::rename(ID = sample)
colnames(METADATA.PICARD_CE) = gsub('AlignmentSummaryMetrics__','',colnames(METADATA.PICARD_CE))
colnames(METADATA.PICARD_CE) = gsub('RnaSeqMetrics__','',colnames(METADATA.PICARD_CE))

METADATA.PICARD_TC_ID <- 'syn8698211';
ALL_USED_IDs[length(ALL_USED_IDs)+1] = METADATA.PICARD_TC_ID
METADATA.PICARD_TC <- METADATA.PICARD_TC_ID %>%
  CovariateAnalysis::downloadFile() %>%
  dplyr::rename(ID = sample)
colnames(METADATA.PICARD_TC) = gsub('AlignmentSummaryMetrics__','',colnames(METADATA.PICARD_TC))
colnames(METADATA.PICARD_TC) = gsub('RnaSeqMetrics__','',colnames(METADATA.PICARD_TC))

# Merge all metadata
METADATA = list(METADATA_TC, METADATA_CE) %>%
  data.table::rbindlist(use.names = T, fill = T) %>%
  dplyr::inner_join(list(METADATA.PICARD_TC, METADATA.PICARD_CE) %>%
                      data.table::rbindlist(use.names = T, fill = T)) %>%
  as.data.frame

# Get gene specific parameters from synapse
GENE.PARAM = downloadFile('syn8449369')
ALL_USED_IDs = c(ALL_USED_IDs, 'syn8449369')

GENE.LEN = dplyr::select(GENE.PARAM, ensembl_gene_id, gene.length) %>% unique()
rownames(GENE.LEN) = GENE.LEN$ensembl_gene_id

GENE.GC = dplyr::select(GENE.PARAM, ensembl_gene_id, percentage_gc_content) %>% unique()
rownames(GENE.GC) = GENE.GC$ensembl_gene_id

# Samples excluded by MAYO investigators
SAMPLES.EXCLUDE = c(downloadFile('syn6126119')$`Sample Name`,
                    downloadFile('syn6126114')$`Sample Name`)
ALL_USED_IDs = c(ALL_USED_IDs, 'syn6126119', 'syn6126114')
```
Following `r length(SAMPLES.EXCLUDE)` samples were removed from analysis as original investigators tagged them as outliers for various reasons as described here syn6126119, syn6126114
Samples removed are `r paste(SAMPLES.EXCLUDE, collapse = ', ')`

### Data preprocessing
```{r preprocess.data, echo=TRUE}
# Filter metadata
METADATA = METADATA %>%
  dplyr::filter(ID %in% colnames(COUNT)) %>%
  dplyr::filter(!is.na(RIN)) %>%
  dplyr::filter(!is.na(PCT_INTRONIC_BASES)) %>%
  dplyr::filter(!is.na(AgeAtDeath)) %>%
  dplyr::filter(!is.na(Source)) %>%
  dplyr::filter(!(ID %in% SAMPLES.EXCLUDE)) %>%
  as.data.frame()

# Fix Tissue
METADATA$Tissue = gsub('CER', 'CBE', METADATA$Tissue)

# Fix AgeAtDeath
METADATA = METADATA %>%
  dplyr::mutate(AgeAtDeath = gsub("_or_above", "", AgeAtDeath))

# Fix Diagnosis
METADATA = METADATA %>%
  dplyr::mutate(Source.Diagnosis = Diagnosis) %>%
  dplyr::mutate(Source.Diagnosis = factor(Source.Diagnosis,
                                          levels = c('AD', 'Control', 'Pathologic Aging', 'PSP'),
                                          labels = c('AD', 'CONTROL', 'PATH_AGE', 'PSP'))) %>%
  dplyr::mutate(Diagnosis = gsub("Pathologic Aging", "OTHER", Diagnosis),
                Diagnosis = gsub("PSP", "OTHER", Diagnosis),
                Diagnosis = factor(Diagnosis, 
                                   levels = c("AD", "Control", "OTHER"),
                                   labels = c('AD', 'CONTROL', 'OTHER'))) %>%
  dplyr::mutate(Tissue.Diagnosis = paste(Tissue, Diagnosis, sep = '.'),
                Tissue.SourceDiagnosis = paste(Tissue, Source.Diagnosis, sep = '.'))

# Fix Gender
METADATA = METADATA %>%
  dplyr::mutate(Sex = Gender,
                Sex = factor(Sex, levels = c('F','M'), labels = c('FEMALE','MALE')))

# Get RIN square
METADATA = METADATA %>%
  dplyr::mutate(RIN2 = RIN^2)

# Add apoe4 genotype (0, 1, 2)
METADATA$APOE4 = 0
METADATA$APOE4[METADATA$ApoE %in% c(24, 34)] = 1
METADATA$APOE4[METADATA$ApoE %in% c(44)] = 2
METADATA$Tissue.APOE4 = paste(METADATA$Tissue, METADATA$APOE4, sep = '.')

# Match covariates to expression data
indToRetain = intersect(METADATA$ID, colnames(COUNT))
indRemoved = setdiff(colnames(COUNT), METADATA$ID)

COUNT <- COUNT[, indToRetain]

rownames(METADATA) = METADATA$ID
METADATA = METADATA[indToRetain,]
```
`r dim(COUNT)[2]` samples from `r length(unique(METADATA$Donor_ID))` subjects were obtained from the Mayo cohorts in AMP-AD reprocessed rnaseq project. 

Following samples were removed `r indRemoved`

### Predict missing PMI
```{r predict.pmi}
# Get PMI
PMI = METADATA[,c('PMI', 'ID', 'Donor_ID'), drop = F]
PMI$PMI = PMI$PMI

# Get expression (convert counts to cpm)
expr = voom(COUNT, design = NULL)$E
ind = which(rowSums(expr>=1)/dim(expr)[2] >= 0.5)
expr = expr[ind,]

# Combine expression from different regions of brain of an individual into one
expr = plyr::dlply(PMI, .(Donor_ID), .fun = function(x, expr){
  data.frame(value = rowMeans(expr[,x$ID,drop = F], na.rm = T)) %>%
    plyr::rename(c('value' = unique(x$Donor_ID)))
}, expr, .parallel = F) %>%
  do.call(cbind,.)

# Split data into training and prediction set
PMI = dplyr::select(PMI, Donor_ID, PMI) %>% unique()
rownames(PMI) = PMI$Donor_ID
PMI = PMI[colnames(expr),]

# Fit a logistic regression model
x.train = expr[,!is.na(PMI$PMI)]
x.predict = expr[,is.na(PMI$PMI)]

y.train = PMI[!is.na(PMI$PMI),]
y.train = y.train[colnames(x.train), 'PMI']

plr.model = cv.glmnet(t(x.train), y.train, family = 'gaussian')
coeff = as.matrix(coef.glmnet(plr.model, s = 'lambda.min'))
ssres = sum((predict(plr.model, t(x.train), s = 'lambda.min', type = 'response') - y.train)^2)
sstot = sum((y.train-mean(y.train, na.rm = T))^2, na.rm = T)
R2.allgenes = 1-(ssres/sstot)

y.predict.all = predict(plr.model, t(x.predict), s = 'lambda.min', type = 'response') %>%
  rownameToFirstColumn('Donor_ID') %>%
  plyr::rename(c('1' = 'PMI'))

# Get genes that are predictors of PMI and use them as control probes
CONTROL.PROBES_ID = 'syn6145639'
ALL_USED_IDs = c(ALL_USED_IDs, CONTROL.PROBES_ID)
CONTROL.PROBES = fread(synGet(CONTROL.PROBES_ID)@filePath, data.table = F) %>%
  dplyr::mutate(ID = x) %>%
  tidyr::separate(ID, c('ensembl_gene_id', 'position'), sep = '\\.')

# Initial normalisation of gene expression
ind = rownames(expr) %in% CONTROL.PROBES$ensembl_gene_id 
expr = expr[ind,]

# Fit a logistic regression model
x.train = expr[,!is.na(PMI$PMI)]
x.predict = expr[,is.na(PMI$PMI)]

y.train = PMI[!is.na(PMI$PMI),]
y.train = y.train[colnames(x.train), 'PMI']

plr.model = cv.glmnet(t(x.train), y.train, family = 'gaussian')
coeff = as.matrix(coef.glmnet(plr.model, s = 'lambda.min'))
ssres = sum((predict(plr.model, t(x.train), s = 'lambda.min', type = 'response') - y.train)^2)
sstot = sum((y.train-mean(y.train, na.rm = T))^2, na.rm = T)
R2.smallgenes = 1-(ssres/sstot)

y.predict = predict(plr.model, t(x.predict), s = 'lambda.min', type = 'response') %>%
  rownameToFirstColumn('Donor_ID') %>%
  plyr::rename(c('1' = 'PMI'))

PMI = PMI %>% 
  dplyr::select(Donor_ID, PMI) %>%
  dplyr::filter(!is.na(PMI)) %>%
  list(y.predict) %>%
  data.table::rbindlist(use.names = T, fill = T)
PMI$PMI[PMI$PMI < 0] = 0

METADATA = METADATA %>% 
  dplyr::select(-PMI) %>%
  dplyr::left_join(PMI)
```
Fitted R2 values are, (i) with all gx features `r round(R2.allgenes, 3)`, (ii) with small set of inferred gx features `r round(R2.smallgenes,3)`

### Covariate clustering
Determine relationship between covariates
```{r covariates.clustering}
primaryVariable <- c("Tissue.SourceDiagnosis", "Tissue.Diagnosis", "Tissue.APOE4")
FactorCovariates <- c("Donor_ID", "Source", "Sex", "FLOWCELL", "Tissue.SourceDiagnosis", "Tissue.Diagnosis", "Tissue.APOE4")
ContCovariates <- c("RIN", "RIN2", "AgeAtDeath","PMI", "PCT_PF_READS_ALIGNED", "PCT_CODING_BASES",
                    "PCT_INTERGENIC_BASES", "PCT_INTRONIC_BASES", "PCT_RIBOSOMAL_BASES")

# Find inter relation between factor covariates
COVARIATES = METADATA[,c(FactorCovariates,ContCovariates),drop=F]
rownames(COVARIATES) <- METADATA$ID

# Convert factor covariates to factors
COVARIATES[,FactorCovariates] = lapply(COVARIATES[,FactorCovariates], factor)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.character)
COVARIATES[,ContCovariates] = lapply(COVARIATES[,ContCovariates], as.numeric)
```
Correlation/association between covariates at an FDR <= 0.1
```{r covariates.correlation, fig.width=10, fig.height=6}
COVARIATES.CORRELATION = getAssociationStatistics(COVARIATES, PVAL = 0.05)
draw(COVARIATES.CORRELATION$plot, heatmap_legend_side = 'left', padding  = unit(c(18,2,2,18), 'mm'))
```
### Explore metadata
```{r data.explore, fig.width = 12, fig.height = 8}
my.theme = theme(legend.position = 'top', axis.text.x = element_text(angle = 90, hjust = 1))

# RIN
p = list()
p[[1]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = RIN)) + geom_boxplot()
p[[1]] = p[[1]] + ggtitle('RIN') + my.theme

# AgeAtDeath
p[[2]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(AgeAtDeath))) + geom_boxplot()
p[[2]] = p[[2]] + ggtitle('AgeAtDeath') + my.theme

# PMI
p[[3]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PMI))) + geom_boxplot()
p[[3]] = p[[3]] + ggtitle('PMI') + my.theme

# Ribosomal bases
p[[4]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_RIBOSOMAL_BASES))) + geom_boxplot()
p[[4]] = p[[4]] + ggtitle('Fraction of Ribosomal Bases') + my.theme

# Intronic bases
p[[5]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_INTRONIC_BASES))) + geom_boxplot()
p[[5]] = p[[5]] + ggtitle('Fraction Intronic Bases') + my.theme

# Intergenic bases
p[[6]] = ggplot(COVARIATES, aes(x = Tissue.Diagnosis, y = as.numeric(PCT_INTERGENIC_BASES))) + geom_boxplot()
p[[6]] = p[[6]] + ggtitle('Fraction Intergenic Bases') + my.theme

multiplot(plotlist = p, cols = 3)
```

### Filter genes
* Remove genes that have less than 1 cpm counts in at least 50% of samples per Tissue x Diagnosis
* Remove genes with missing gene length and percentage GC content
```{r filter.genes}
genesToAnalyze = COVARIATES %>%
  rownameToFirstColumn('SampleID') %>%
  dlply(.(Tissue.Diagnosis), .fun = function(mtd, count){
    processed.counts = getGeneFilteredGeneExprMatrix(count[,mtd$SampleID],
                                                     MIN_GENE_CPM=1, 
                                                     MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0.5)
    processed.counts$filteredExprMatrix$genes
  }, COUNT)

genesToAnalyze = unlist(genesToAnalyze) %>% 
  unique() %>%
  intersect(GENE.GC$ensembl_gene_id[!is.na(GENE.GC$percentage_gc_content)]) %>%
  intersect(GENE.LEN$ensembl_gene_id[!is.na(GENE.LEN$gene.length)]) %>%
  setdiff(c("N_unmapped", "N_multimapping", "N_noFeature", "N_ambiguous"))

PROCESSED_COUNTS = getGeneFilteredGeneExprMatrix(COUNT[genesToAnalyze, ], 
                                                 MIN_GENE_CPM=0, 
                                                 MIN_SAMPLE_PERCENT_WITH_MIN_GENE_CPM=0)

# Check gene biotype
## Define biomart object
mart <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", host = "dec2016.archive.ensembl.org", dataset = "hsapiens_gene_ensembl")

## Query biomart
Ensemble2HGNC <- getBM(attributes = c("ensembl_gene_id", "hgnc_symbol", "gene_biotype"),
                       filters = "ensembl_gene_id", 
                       values = PROCESSED_COUNTS$filteredExprMatrix$genes,
                       mart = mart)

summary(factor(Ensemble2HGNC$gene_biotype)) %>%
  rownameToFirstColumn('Biotype') %>%
  dplyr::rename(fraction = DF) %>%
  dplyr::mutate(fraction = fraction/dim(PROCESSED_COUNTS$filteredExprMatrix$genes)[1]) %>%
  dplyr::filter(fraction >= 0.01) %>%
  kable
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

### Library Normalisation
Library normalisation is performed using TMM
```{r tmm}
# Normalise using TMM
TMM.GENE_EXPRESSION = calcNormFactors(PROCESSED_COUNTS$filteredExprMatrix, method = 'TMM')
VOOM.GENE_EXPRESSION = voom(TMM.GENE_EXPRESSION)
```

### Outlier Analysis
#### Sample outliers
Outlier analysis is performed before library normalisation with raw cpm counts
```{r outlier.analysis, cache = FALSE, fig.width = 10}
indToRemove = c("11311_CER", "1923_CER", "1923_TCX", "11396_TCX", "11294_TCX", "11408_TCX",
                '1950_TCX', '1950_CER', '1925_TCX', '1957_CER')

# Find principal components of expression to plot
PC <- prcomp(VOOM.GENE_EXPRESSION$E, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  dplyr::mutate(label = SampleID) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')
plotdata$label[!(plotdata$SampleID %in% indToRemove)] = ''

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Source, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="top") 
p <- p + facet_grid(Tissue~.+Diagnosis, scales = 'free')
p <- p + geom_text(aes(label= label), size=4, hjust=0)
p

# Plot abberent distribution of logcpm counts
tmp1 = VOOM.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('Gene.ID') %>%
  tidyr::gather(SampleID, logCPM, -Gene.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')

p = ggplot(tmp1 %>%
             dplyr::filter(SampleID %in% indToRemove) %>%
             droplevels(),
           aes(x = logCPM)) + geom_density() 
p = p + theme(legend.position = 'top') + facet_grid(Tissue~.+Diagnosis)
p

indToRetain = setdiff(colnames(PROCESSED_COUNTS$filteredExprMatrix$counts), indToRemove)
PROCESSED_COUNTS$filteredExprMatrix$counts = PROCESSED_COUNTS$filteredExprMatrix$counts[,indToRetain]
VOOM.GENE_EXPRESSION$E = VOOM.GENE_EXPRESSION$E[,indToRetain]
COVARIATES = COVARIATES[indToRetain,]

tmp = COVARIATES %>%
  dplyr::group_by(Tissue.Diagnosis) %>%
  dplyr::summarise(count = n()) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.') %>%
  tidyr::spread(Diagnosis, count)
```
Processing `r dim(PROCESSED_COUNTS$filteredExprMatrix)[1]` genes in `r dim(PROCESSED_COUNTS$filteredExprMatrix)[2]` samples

Based on the expression pattern following samples were tagged as outliers: `r paste(indToRemove, collapse = ', ')`

Distribution of samples are: `r kable(tmp)`

#### Gene outliers
Assign NA values to genes that are above and below 3 std deviation of its distribution
```{r winsorise.data}
# Set gene counts in specific samples that are deviating 3 sd from other samples to 3SD limit
LOG.CPM = apply(VOOM.GENE_EXPRESSION$E, 1, function(x){
  mn = mean(x, na.rm = T)
  std.dev = sd(x, na.rm = T)
  
  x[x < (mn-3*std.dev)] = NA
  x[x > (mn+3*std.dev)] = NA
  return(x)
}) %>% t
VOOM.GENE_EXPRESSION$E = LOG.CPM
VOOM.GENE_EXPRESSION$E.no.na = VOOM.GENE_EXPRESSION$E
VOOM.GENE_EXPRESSION$E.no.na[is.na(VOOM.GENE_EXPRESSION$E.no.na)] = 0
LIB.SIZE = colSums(PROCESSED_COUNTS$filteredExprMatrix$counts)
NEW.COUNTS = (2^LOG.CPM) * t(replicate(dim(LOG.CPM)[1], LIB.SIZE))/1e6
```

### Sample clustering
PCA based clustering of samples
```{r decompse.normalise.data, fig.height=8, fig.width=8, results='asis', cache=FALSE}
# Find principal components of expression to plot
PC <- prcomp(VOOM.GENE_EXPRESSION$E.no.na, scale.=T, center = T)

# Plot first 2 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Source, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="top") + facet_grid(Tissue+.~Diagnosis, scales = 'free_y')
p
```

Tree based clustering of samples
```{r decompse.normalise.data.1, fig.height=6, fig.width=10, results='asis'}
COVARIATES.tmp = (COVARIATES[,c(FactorCovariates), drop = F])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(VOOM.GENE_EXPRESSION$E.no.na)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```

### Distribution of samples (log cpm)
```{r lcpm.dist, cache=FALSE, fig.height=10, fig.width=20}
# Plot abberent distribution of logcpm counts
tmp1 = VOOM.GENE_EXPRESSION$E.no.na %>%
  rownameToFirstColumn('Gene.ID') %>%
  tidyr::gather(SampleID, logCPM, -Gene.ID) %>%
  left_join(COVARIATES %>%
              rownameToFirstColumn('SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Tissue', 'Diagnosis'), sep = '\\.')

p = ggplot(tmp1, aes(x = logCPM)) + geom_density() 
p = p + theme(legend.position = 'NONE') + facet_grid(Tissue+.~Diagnosis, scale = 'free')
p
```

Coexpression of genes 
```{r coexp1, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(VOOM.GENE_EXPRESSION$E.no.na))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```

### Significant Covariates
Correlation between pca of unadjusted mRNA expression and covariates are used to find significant covariates
```{r preadj.covariates, cache=TRUE}
# Find correlation between PC's of gene expression with covariates
preAdjustedSigCovars = runPCAandPlotCorrelations(VOOM.GENE_EXPRESSION$E.no.na, 
                                                 COVARIATES,
                                                 'NULL design(voom-normalized)', 
                                                 isKeyPlot=TRUE, 
                                                 MIN_PVE_PCT_PC = 1)
```

Significant covariates to adjust at FDR 0.1 are `r preAdjustedSigCovars$significantCovars`
```{r preadj.covariates.plot, fig.width=12, fig.height=8}
preAdjustedSigCovars[["PC_res"]][[2]]$plotData
```

### Normalisation (iterative design)
Since many covariates are correlated, re-normalising and re-adjusting COUNTS with an iterative design matrix.

NOTE:
1. Using a mixed effect model where random effect is chosen as Donor_ID
2. Adding Source, FLOWCELL and Gender a priori to variable selection
3. Primary variable of interest Tissue.Diagnosis is excluded from the pool of available covariates for selection
```{r iterative.norm, results='asis'}
# Primary variable of interest
postAdjustCovars = c('Source', 'FLOWCELL', 'Sex');

# Assign residual covariates
residualCovars = setdiff(preAdjustedSigCovars$significantCovars, 
                         c(postAdjustCovars, primaryVariable, 'Donor_ID'))
residualSigCovars = preAdjustedSigCovars
covariatesEffects = preAdjustedSigCovars$Effects.significantCovars[residualCovars]
postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects))) %>% unique()
notEstimable = c()

loopCount = 0 
while(length(residualSigCovars$significantCovars)!=0 && loopCount <= 20){
  writeLines(paste('Using following covariates in the model:',
                   paste(postAdjustCovars, collapse=', '),
                   'as fixed effects and Donor_ID as random effect'))
  
  # Post adjusted design matrix
  DM1 = getDesignMatrix(COVARIATES[,postAdjustCovars,drop=F],Intercept = F)
  DM1$design = DM1$design[,linColumnFinder(DM1$design)$indepCols]
  
  # Estimate voom weights for dispersion control
  cnts = NEW.COUNTS; cnts[is.na(cnts)] = 0
  TMM.GENE_EXPRESSION = calcNormFactors(cnts, method = 'TMM')
  VOOM.GENE_EXPRESSION = voom(cnts, design=DM1$design, 
                              plot=F, na.rm = T,
                              lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)
  
  # Calculate correlation values of random effects
  correlation = parallelDuplicateCorrelation(VOOM.GENE_EXPRESSION,
                                             block = COVARIATES$Donor_ID,
                                             method = 'lmer')
  # correlation = list(); correlation$cor = 0.3819258
  
  if (!is.nan(correlation$cor)){
    # Re-estimate voom weights
    VOOM.GENE_EXPRESSION = voom(cnts, 
                                design=DM1$design, plot=F, 
                                block = COVARIATES$Donor_ID, 
                                correlation = correlation$cor,
                                lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)
    
    # Fit linear model using new weights and new design
    VOOM.ADJUSTED.FIT = lmFit(VOOM.GENE_EXPRESSION)
    
    # Residuals after normalisation
    RESIDUAL.GENE_EXPRESSION = residuals.MArrayLM(VOOM.ADJUSTED.FIT,
                                                  VOOM.GENE_EXPRESSION$E)
  } else {
    notEstimable = c(notEstimable, postAdjustCovars[length(postAdjustCovars)])
    postAdjustCovars = postAdjustCovars[1:(length(postAdjustCovars)-1)]
  }
  
  # Residual covariates to choose from
  residCovars <- setdiff(c(FactorCovariates,ContCovariates),
                         c(postAdjustCovars, primaryVariable, 'Donor_ID', notEstimable))
  
  # Find PC of residual gene expression and significant covariates that are highly correlated with PCs
  expr = RESIDUAL.GENE_EXPRESSION; expr[is.na(expr)] = 0
  residualSigCovars = runPCAandPlotCorrelations(expr, 
                                                COVARIATES[, residCovars, drop=F], 
                                                'adjusted design(voom-normalized)',
                                                isKeyPlot=TRUE)
  
  # Add postadjusted covariates (if any)
  residCovars = setdiff(residualSigCovars$significantCovars, c(postAdjustCovars, primaryVariable, notEstimable))
  covariatesEffects = residualSigCovars$Effects.significantCovars[residCovars]
  
  postAdjustCovars = c(postAdjustCovars, names(which.max(covariatesEffects)))
  loopCount = loopCount + 1
}

modelStr <- paste(paste(gsub('_','\\\\_',postAdjustCovars), collapse=', '),
                  'as fixed effects')

tmp <- paste('Using following covariates in the final model:', modelStr)
```
`r tmp`

### Sanity check
```{r residual.adj, fig.width=12, fig.height=8}
# Find PC of residual gene expression and significant covariates that are highly correlated with PCs
residualSigCovars = runPCAandPlotCorrelations(expr, 
                                              COVARIATES,
                                              'adjusted design(voom-normalized)',
                                              isKeyPlot=TRUE)

residualSigCovars[["PC_res"]][[2]]$plotData
```
Coexpression of genes 
```{r coexp2, cache=FALSE, fig.height=5, fig.width=5}
cr = cor(t(expr))
hist(cr, main = 'Distribution of correlation between genes', xlab = 'Correlation')
```
PCA of residual data
```{r decompse.normalise.data2.1, fig.height=10, fig.width=8, results='asis'}
# Find principal components of expression to plot
PC <- prcomp(expr, scale.=T, center = T)

# Plot first 4 PCs
plotdata <- data.frame(SampleID=rownames(PC$rotation), 
                       PC1=PC$rotation[,1], 
                       PC2=PC$rotation[,2])

plotdata <- left_join(plotdata, rownameToFirstColumn(COVARIATES, 'SampleID')) %>%
  tidyr::separate(Tissue.Diagnosis, c('Region','Diagnosis'), sep = '\\.') %>% 
  dplyr::mutate(Region = factor(Region),
                Source = factor(Source))

p <- ggplot(plotdata, aes(x=PC1, y=PC2))
p <- p + geom_point(aes(shape=Source, color=Diagnosis, size=RIN))
p <- p + theme_bw() + theme(legend.position="right") + facet_grid(Region~., scales = 'free_y')
p
```
Tree based clustering of residual data
```{r decompse.normalise.data2.2, fig.height=8, fig.width=12, results='asis'}
# Eucledian tree based analysis
COVARIATES.tmp = data.matrix(COVARIATES[,FactorCovariates])
COVARIATES.tmp[is.na(COVARIATES.tmp)] = 0

tree = hclust(as.dist(t(expr)))
cols = WGCNA::labels2colors(COVARIATES.tmp);

WGCNA::plotDendroAndColors(tree, 
                           colors = cols, 
                           dendroLabels = FALSE, 
                           abHeight = 0.80, 
                           main = "Sample dendrogram",
                           groupLabels = colnames(COVARIATES.tmp))
```

### Adjust data with covariates for Network Analysis
Identified covariates are regressed out from the expression matrix for network analysis
```{r network.adjust}
# Get design matrix
DESIGN.NET = getDesignMatrix(COVARIATES[, postAdjustCovars, drop = F], Intercept = F)
DESIGN.NET = DESIGN.NET$design[,linColumnFinder(DESIGN.NET$design)$indepCols]

# Re-estimate voom weights
VOOM.NET.WEIGHTS = voom(cnts, 
                        design = DESIGN.NET, plot=F,
                        block = COVARIATES$Donor_ID, 
                        correlation = correlation$cor,
                        lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
VOOM.NET.FIT = lmFit(VOOM.NET.WEIGHTS)

# Residuals after normalisation
RESIDUAL.NET.GENE_EXPRESSION = residuals.MArrayLM(VOOM.NET.FIT,
                                                  VOOM.GENE_EXPRESSION$E)
```

### SVA Adjustments for eQTL analysis
Conditioned on primary variable (Tissue.Diagnosis) and identified covariates estimate surrogate variables using SVA package
```{r sva.adjust}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS)

# Get (null) design matrix
MODEL0 = DESIGN$design[,-grep(primaryVariable[2],colnames(DESIGN$design))] # Get null model by removing variable of interest
MODEL0 = MODEL0[,linColumnFinder(MODEL0)$indepCols]
MODEL1 = DESIGN$design
MODEL1 = MODEL1[,linColumnFinder(MODEL1)$indepCols]

# Get residuals from differential expression model
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(FIT, VOOM.WEIGHTS$E)

# Compute actual variance of all principal components
expr = RESIDUAL.SVA.GENE_EXPRESSION
expr[is.na(expr)] = 0
tmp = svd(expr)
actual.var = tmp$d^2/sum(tmp$d^2)

# Compute permuted variance of all principal components
permuted.var = foreach(i = 1:20, .combine = rbind) %dopar% {
  tmp.residual = t(apply(expr, 1, sample, replace = FALSE))
  tmp = svd(tmp.residual)
  permuted.var = tmp$d^2/sum(tmp$d^2)
}
permuted.var = apply(permuted.var, 2, mean)
NUM.SV = sum(actual.var >= permuted.var[1])

# Plot variance components
var.comp = data.frame(component = 1:length(actual.var), 
                      residual = actual.var, 
                      permuted.residual = permuted.var) %>%
  tidyr::gather(data, value, -component)
p = ggplot(var.comp %>% filter(component <= round(NUM.SV*1.2)), aes(x = component, y = value, color = data)) + geom_point()
p = p + geom_hline(yintercept=permuted.var[1], linetype = 'dashed') + xlab('Singular Dimension Index')
p = p + geom_vline(xintercept=NUM.SV, linetype = 'dashed') + ylab('Fraction of Variance Explained')
p = p + theme(legend.position = c(0.8, 0.8), legend.title = element_blank())
p

# Estimate surrogate variables
SURR.VAR = irwsva.build(VOOM.WEIGHTS$E,
                        MODEL1, MODEL0, n.sv = NUM.SV, 
                        B = 30, tol = 1e-20)$sv

colnames(SURR.VAR) = paste0('SV',1:dim(SURR.VAR)[2])
rownames(SURR.VAR) = rownames(MODEL1)

# Re-estimate voom weights
VOOM.SVA.WEIGHTS = voom(cnts, 
                        design = cbind(MODEL1, SURR.VAR), plot=F,
                        block = COVARIATES$Donor_ID, 
                        correlation = correlation$cor,
                        lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
VOOM.SVA.FIT = lmFit(VOOM.SVA.WEIGHTS)

# Residuals after normalisation
RESIDUAL.SVA.GENE_EXPRESSION = residuals.MArrayLM(VOOM.SVA.FIT,
                                                  VOOM.SVA.WEIGHTS$E)

# Add variable of interest back to the residuals
varsToAddIn = grep("Tissue.Diagnosis", colnames(MODEL1), value = T)
RESIDUAL.SVA.GENE_EXPRESSION = RESIDUAL.SVA.GENE_EXPRESSION + 
  VOOM.SVA.FIT$coefficients[,varsToAddIn] %*% t(VOOM.SVA.FIT$design[,varsToAddIn])
```

### Differential expression analysis (with Tissue.SourceDiagnosis as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Tissue.SourceDiagnosis
1. CBE.AD: Alzheimers Disease samples from Cerebellum region
2. CBE.CONTROL: Control samples from Cerebellum region
3. CBE.PATH_AGE: Pathological ageing samples from Cerebellum region
4. CBE.PSP: Palsy samples from Cerebellum region
5. TCX.AD: Alzheimers Disease samples from temporal cortex region
6. TCX.CONTROL: Control samples from temporal cortex region
7. TCX.PATH_AGE: Pathalogical ageing samples from temporal cortex region
8. TCX.PSP: Palsy samples from temporal cortex region

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp, fig.height=10, fig.width=18}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[1], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS)

# Fit contrast
contrast = makeContrasts(contrasts=c(
  "Tissue.SourceDiagnosisCBE.AD-Tissue.SourceDiagnosisCBE.CONTROL",
  "Tissue.SourceDiagnosisCBE.PATH_AGE-Tissue.SourceDiagnosisCBE.CONTROL",
  "Tissue.SourceDiagnosisCBE.PSP-Tissue.SourceDiagnosisCBE.CONTROL",
  "Tissue.SourceDiagnosisCBE.AD-Tissue.SourceDiagnosisCBE.PATH_AGE",
  "Tissue.SourceDiagnosisTCX.AD-Tissue.SourceDiagnosisTCX.CONTROL",
  "Tissue.SourceDiagnosisTCX.PATH_AGE-Tissue.SourceDiagnosisTCX.CONTROL",
  "Tissue.SourceDiagnosisTCX.PSP-Tissue.SourceDiagnosisTCX.CONTROL",
  "Tissue.SourceDiagnosisTCX.AD-Tissue.SourceDiagnosisTCX.PATH_AGE"),
  levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.SourceDiagnosis','',Comparison),
                Study = 'MAYO',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue.ref','reference'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue.ag','against'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  left_join(GENE.PARAM %>%
              dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gc_content, gene.length) %>%
              unique())
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

tmp = DE %>%
  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue.ref) %>%
  group_by(Tissue.ref, Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(Tissue.ref+.~Comparison, scales = 'fixed')
p

all.diff.exp = list(SourceDiagnosis = DE)
all.fit = list(SourceDiagnosis = FIT)
```

### Differential expression analysis (with Tissue.Diagnosis as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Tissue.Diagnosis
1. CER.AD: Alzheimers disease samples from cerebellum region
2. CER.CONTROL: Control samples from cerebellum region
3. CER.OTHER: Progressive supranuclear palsy and pathological aging samples from Cerebellum region
4. TCX.AD: Alzheimers disease samples from temporal cortex region
5. TCX.CONTROL: Control samples from temporal cortex region
6. TCX.OTHER: Progressive supranuclear palsy and pathological aging samples from temporal cortex region

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp.1, fig.height=10, fig.width=18}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[2], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS)

# Fit contrast
contrast = makeContrasts(contrasts=c(
  "Tissue.DiagnosisCBE.AD-Tissue.DiagnosisCBE.CONTROL",
  "Tissue.DiagnosisCBE.AD-Tissue.DiagnosisCBE.OTHER",
  "Tissue.DiagnosisCBE.OTHER-Tissue.DiagnosisCBE.CONTROL",
  "Tissue.DiagnosisTCX.AD-Tissue.DiagnosisTCX.CONTROL",
  "Tissue.DiagnosisTCX.AD-Tissue.DiagnosisTCX.OTHER",
  "Tissue.DiagnosisTCX.OTHER-Tissue.DiagnosisTCX.CONTROL"),
  levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.Diagnosis','',Comparison),
                Study = 'MAYO',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue.ref','reference'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue.ag','against'), sep = '\\.') %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  left_join(GENE.PARAM %>%
              dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gc_content, gene.length) %>%
              unique())
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

tmp = DE %>%
  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue.ref) %>%
  group_by(Tissue.ref, Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(Tissue.ref+.~Comparison, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis = DE))
all.fit = c(all.fit, list(Diagnosis = FIT))
```

### Associate differential expression results with gc content, gene length and average expression
```{r associate.de, fig.height=10, fig.width=15}
pl = list()
pl[[1]] = ggplot(DE %>%
                   dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = log10(gene.length), y = logFC, color = Direction)) + geom_point() 
pl[[1]] = pl[[1]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = log10(gene.length), y = logFC))
pl[[1]] = pl[[1]] + facet_grid(Tissue.ref+.~Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[1]] = pl[[1]] + theme(legend.position = 'top')

pl[[2]] = ggplot(DE %>%
                   dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = percentage_gc_content, y = logFC, color = Direction)) + geom_point()
pl[[2]] = pl[[2]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = percentage_gc_content, y = logFC))
pl[[2]] = pl[[2]] + facet_grid(Tissue.ref+.~Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[2]] = pl[[2]] + theme(legend.position = 'top')

pl[[3]] = ggplot(DE %>%
                   dplyr::filter(Comparison == 'AD-CONTROL'), 
                 aes(x = AveExpr, y = logFC, color = Direction)) + geom_point()
pl[[3]] = pl[[3]] + geom_smooth(method = 'loess', inherit.aes = FALSE, aes(x = AveExpr, y = logFC))
pl[[3]] = pl[[3]] + facet_grid(Tissue.ref+.~Comparison) + scale_color_manual(values = c('green','grey','red'))
pl[[3]] = pl[[3]] + theme(legend.position = 'top')

multiplot(plotlist = pl, cols = 3)
```

### Differential expression analysis (with Tissue.APOE as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Interpretation of Tissue.Diagnosis
1. CBE.0: No APOE4 allele in cerebellum
2. CBE.1: 1 APOE4 allele in cerebellum
3. CBE.2: 2 APOE4 allele in cerebellum
4. TCX.0: No APOE4 allele in temporal cortex
5. TCX.1: 1 APOE4 allele in temporal cortex
6. TCX.2: 2 APOE4 allele in temporal cortex

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp.2, fig.height=10, fig.width=18}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c(primaryVariable[3], postAdjustCovars), drop = F], Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS)

# Fit contrast
contrast = makeContrasts(contrasts=c(
  "Tissue.APOE4CBE.2-Tissue.APOE4CBE.0",
  "Tissue.APOE4CBE.2-Tissue.APOE4CBE.1",
  "Tissue.APOE4CBE.1-Tissue.APOE4CBE.0",
  "Tissue.APOE4TCX.2-Tissue.APOE4TCX.0",
  "Tissue.APOE4TCX.2-Tissue.APOE4TCX.1",
  "Tissue.APOE4TCX.1-Tissue.APOE4TCX.0"),
  levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.APOE4','',Comparison),
                Study = 'MAYO',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue.ref','reference'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue.ag','against'), sep = '\\.') %>%
  dplyr::mutate(reference = paste0('APOE4',reference),
                against = paste0('APOE4',against)) %>%
  tidyr::unite(Comparison, reference, against, sep = '-') %>%
  left_join(GENE.PARAM %>%
              dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gc_content, gene.length) %>%
              unique())
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

tmp = DE %>%
  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue.ref) %>%
  group_by(Tissue.ref, Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(Tissue.ref+.~Comparison, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(APOE4 = DE))
all.fit = c(all.fit, list(APOE4 = FIT))
```

### Differential expression analysis (with Tissue.Diagnosis x Sex as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp2, fig.height=5, fig.width=18}
# Get design matrix
COVARIATES$Tissue.Diagnosis.Sex = paste(COVARIATES$Tissue.Diagnosis, COVARIATES$Sex, sep = '.') %>%
  factor()
DESIGN = getDesignMatrix(COVARIATES[, c('Tissue.Diagnosis.Sex', setdiff(postAdjustCovars, 'Sex')), drop = F], 
                         Intercept = F)
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit(VOOM.WEIGHTS)

# Fit contrast
contrast = makeContrasts(contrasts=c(
  "Tissue.Diagnosis.SexCBE.AD.FEMALE-Tissue.Diagnosis.SexCBE.CONTROL.FEMALE",
  "Tissue.Diagnosis.SexCBE.AD.MALE-Tissue.Diagnosis.SexCBE.CONTROL.MALE",
  
  "Tissue.Diagnosis.SexTCX.AD.FEMALE-Tissue.Diagnosis.SexTCX.CONTROL.FEMALE",
  "Tissue.Diagnosis.SexTCX.AD.MALE-Tissue.Diagnosis.SexTCX.CONTROL.MALE"),
  levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.Diagnosis.Sex','',Comparison),
                Study = 'MAYO',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue.ref','Dx.ref','Sex.ref'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue.ag','Dx.ag','Sex.ag'), sep = '\\.') %>%
  tidyr::unite(Comparison, Dx.ref, Dx.ag, sep = '-') %>%
  left_join(GENE.PARAM %>%
              dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gc_content, gene.length) %>%
              unique())
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

tmp = DE %>%
  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue.ref, Sex.ref) %>%
  group_by(Tissue.ref, Sex.ref, Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(Comparison+.~Tissue.ref+Sex.ref, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis.Sex = DE))
all.fit = c(all.fit, list(Diagnosis.Sex = FIT))
```

### Differential expression analysis (with Tissue.Diagnosis x AgeAtDeath as primary variable)
Differential expression is performed on the primary variable by controlling for covariates identified above

Genes that are differentially expressed at an FDR <= 0.05 are
```{r diff.exp3, fig.height=5, fig.width=18, cache = FALSE}
# Get design matrix
DESIGN = getDesignMatrix(COVARIATES[, c('Tissue.Diagnosis', setdiff(postAdjustCovars, 'AgeAtDeath')), drop = F], 
                         Intercept = F)
DESIGN$design[,grep('Tissue.Diagnosis',colnames(DESIGN$design))] = DESIGN$design[,grep('Tissue.Diagnosis',colnames(DESIGN$design))] * COVARIATES[,'AgeAtDeath']
colnames(DESIGN$design)[grep('Tissue.Diagnosis',colnames(DESIGN$design))] = 
  paste(colnames(DESIGN$design)[grep('Tissue.Diagnosis',colnames(DESIGN$design))],'AOD', sep = '.')
DESIGN$design = DESIGN$design[,linColumnFinder(DESIGN$design)$indepCols]

# Re-estimate voom weights
VOOM.WEIGHTS = voom(cnts,
                    design=DESIGN$design, plot=F,
                    block = COVARIATES$Donor_ID, 
                    correlation = correlation$cor,
                    lib.size = LIB.SIZE * TMM.GENE_EXPRESSION)

# Fit linear model using new weights and new design
FIT = lmFit( VOOM.WEIGHTS)

# Fit contrast
contrast = makeContrasts(contrasts=c(
  "Tissue.DiagnosisCBE.AD.AOD-Tissue.DiagnosisCBE.CONTROL.AOD",
  "Tissue.DiagnosisTCX.AD.AOD-Tissue.DiagnosisTCX.CONTROL.AOD"),
  levels = colnames(FIT$coefficients))
FIT.CONTR = contrasts.fit(FIT, contrasts=contrast)
FIT.CONTR = eBayes(FIT.CONTR)

# Get differnetial expression
DE = lapply(1:dim(contrast)[2], function(i, FIT){
  topTable(FIT, coef=i, number = 50000, confint = T) %>%
    rownameToFirstColumn('ensembl_gene_id')
}, FIT.CONTR)
names(DE) = colnames(contrast)

DE = DE %>% 
  rbindlist(idcol = 'Comparison') %>%
  dplyr::mutate(Comparison = gsub('Tissue.Diagnosis','',Comparison),
                Study = 'MAYO',
                Direction = logFC/abs(logFC),
                Direction = factor(Direction, c(-1,1), c('-1' = 'DOWN', '1' = 'UP')),
                Direction = as.character(Direction)) %>%
  tidyr::separate(Comparison, c('from.state','to.state'), sep = '-') %>%
  tidyr::separate(from.state, c('Tissue.ref','Dx.ref','AOD.ref'), sep = '\\.') %>%
  tidyr::separate(to.state, c('Tissue.ag','Dx.ag','AOD.ag'), sep = '\\.') %>%
  tidyr::unite(Comparison, Dx.ref, Dx.ag, sep = '-') %>%
  left_join(GENE.PARAM %>%
              dplyr::select(ensembl_gene_id, hgnc_symbol, percentage_gc_content, gene.length) %>%
              unique())
DE$Direction[DE$adj.P.Val > 0.05 | abs(DE$logFC) < log2(1.2)] = 'NONE'

tmp = DE %>%
  dplyr::select(ensembl_gene_id, Comparison, Direction, Tissue.ref, AOD.ref) %>%
  group_by(Tissue.ref, AOD.ref, Comparison, Direction) %>%
  dplyr::summarise(FDR_0_05_FC_1.2 = length(unique(ensembl_gene_id))) %>%
  spread(Direction, FDR_0_05_FC_1.2) 
kable(tmp)

p = ggplot(DE, aes(y = -log10(adj.P.Val), x = logFC, color = Direction)) + geom_point() + xlim(c(-1,1))
p = p + scale_color_manual(values = c('green','grey','red'))
p = p + facet_grid(Comparison+.~Tissue.ref+AOD.ref, scales = 'fixed')
p

all.diff.exp = c(all.diff.exp, list(Diagnosis.AOD = DE))
all.fit = c(all.fit, list(Diagnosis.AOD = FIT))
```

### Store files in synapse
```{r synapse.store, include=FALSE, eval=TRUE, cache=FALSE}
# Set annotations
all.annotations = annotations(synGet(COUNT_CE_ID))
all.annotations$tissue = c("cerebellum, temporal cortex")

# Code
CODE <- Folder(name = "MAYO Reprocessed RNASeq (TMM Normalised without adjusting for GC and gene length)", parentId = parentId)
CODE <- synStore(CODE)

# Store covariates
COVARIATES = rownameToFirstColumn(COVARIATES, 'SampleID')
write.table(COVARIATES, file = 'MAYO_CBE_TCX_Covariates.tsv', sep = '\t', row.names=F, quote=F)
COV_OBJ = File('MAYO_CBE_TCX_Covariates.tsv', name = 'Covariates', parentId = CODE$properties$id)
all.annotations$fileFormat = "tsv"
all.annotations$dataSubType = 'covariates'
all.annotations$normalizationStatus	= TRUE
all.annotations$normalizationType	= 'TMM'
annotations(COV_OBJ) = all.annotations
COV_OBJ = synStore(COV_OBJ, used = ALL_USED_IDs, activityName = activityName, 
                   executed = thisFile, activityDescription = activityDescription)

# Store filtered counts
PROCESSED_COUNTS$filteredExprMatrix$counts %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MAYO_CBE_TCX_Counts.tsv', sep = '\t', row.names=F, quote=F)
COUNT_OBJ = File('MAYO_CBE_TCX_Counts.tsv', name = 'Counts (filtered raw)', parentId = CODE$properties$id)
all.annotations$dataSubType = 'filteredCounts'
annotations(COUNT_OBJ) = all.annotations
COUNT_OBJ = synStore(COUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store filtered counts
NEW.COUNTS %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MAYO_CBE_TCX_eCounts.tsv', sep = '\t', row.names=F, quote=F)
ECOUNT_OBJ = File('MAYO_CBE_TCX_eCounts.tsv', name = 'Counts (estimated)', parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'estimatedCounts'
annotations(ECOUNT_OBJ) = all.annotations
ECOUNT_OBJ = synStore(ECOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store logCPM
VOOM.GENE_EXPRESSION$E %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MAYO_CBE_TCX_logCPM.tsv', sep = '\t', row.names=F, quote=F)
LCOUNT_OBJ = File('MAYO_CBE_TCX_logCPM.tsv', name = 'Counts (filtered logCPM)', parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'filteredLCPM'
annotations(LCOUNT_OBJ) = all.annotations
LCOUNT_OBJ = synStore(LCOUNT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store design matrix
MODEL1 %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'MAYO_CBE_TCX_Design.tsv', sep = '\t', row.names=F, quote=F)
DM_OBJ = File('MAYO_CBE_TCX_Design.tsv', name = 'Design Matrix', parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'designMatrix'
annotations(DM_OBJ) = all.annotations
DM_OBJ = synStore(DM_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store surrogate variables
SURR.VAR %>%
  rownameToFirstColumn('SampleID') %>%
  write.table(file = 'MAYO_CBE_TCX_SurVar.tsv', sep = '\t', row.names=F, quote=F)
SURR_OBJ = File('MAYO_CBE_TCX_SurVar.tsv', name = 'Surrogate Variables', parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'surrogateVariables'
annotations(SURR_OBJ) = all.annotations
SURR_OBJ = synStore(SURR_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store residual gene expression for eQTL analysis
RESIDUAL.SVA.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MAYO_CBE_TCX_eQTLResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
eEXP_OBJ = File('MAYO_CBE_TCX_eQTLResidualExpression.tsv', 
                name = 'Normalised, covariates and surrogate variable adjusted residual expression (for eQTL)',
                parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'residualGeneExpForeQTL'
annotations(eEXP_OBJ) = all.annotations
eEXP_OBJ = synStore(eEXP_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store residual gene expression for network analysis
RESIDUAL.NET.GENE_EXPRESSION %>%
  rownameToFirstColumn('ensembl_gene_id') %>%
  write.table(file = 'MAYO_CBE_TCX_netResidualExpression.tsv', sep = '\t', row.names=F, quote=F)
nEXP_OBJ = File('MAYO_CBE_TCX_netResidualExpression.tsv', 
                name = 'Normalised, covariates removed residual expression (for network analysis)', 
                parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'residualGeneExpForNetAnlz'
annotations(nEXP_OBJ) = all.annotations
nEXP_OBJ = synStore(nEXP_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store differential expression results
rbindlist(all.diff.exp, use.names = T, fill = T, idcol = 'Model') %>%
  write.table(file = 'MAYO_CBE_TCX_DiffExpression.tsv', sep = '\t', row.names=F, quote=F)
DEXP_OBJ = File('MAYO_CBE_TCX_DiffExpression.tsv', 
                name = 'Differential Expression Results (Tissue.Diagnosis)', 
                parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'diffExp'
annotations(DEXP_OBJ) = all.annotations
DEXP_OBJ = synStore(DEXP_OBJ, activity = synGetActivity(COV_OBJ$properties$id))

# Store all model fits
save(list = 'all.fit', file = 'MAYO_CBE_TCX_allfits.RData')
AFIT_OBJ = File('MAYO_CBE_TCX_allfits.RData', 
                name = 'All model fits (Tissue.Diagnosis)', 
                parentId = CODE$properties$id)
all.annotations@annotations@stringAnnotations$dataSubType = 'modelFits'
all.annotations@annotations@stringAnnotations$fileFormat = 'RData'
annotations(AFIT_OBJ) = all.annotations
AFIT_OBJ = synStore(AFIT_OBJ, activity = synGetActivity(COV_OBJ$properties$id))
# stopCluster(cl)
```
|  *Results*                                  |  *SynapseID*                     |
|  -----------------------------------------  |   ---------                      |
|  Covariates                                 |  `r COV_OBJ$properties$id`       |
|  Counts (raw)                               |  `r COUNT_OBJ$properties$id`     |
|  Counts (estimated)                         |  `r ECOUNT_OBJ$properties$id`    |
|  Counts (lcpm)                              |  `r LCOUNT_OBJ$properties$id`    |
|  Design Matrix                              |  `r DM_OBJ$properties$id`        |
|  Surrogate Variables                        |  `r SURR_OBJ$properties$id`      |
|  Residual Expression (for eQTL)             |  `r eEXP_OBJ$properties$id`      |
|  Residual Expression (for network analysis) |  `r nEXP_OBJ$properties$id`      |
|  Differential Expression                    |  `r DEXP_OBJ$properties$id`      |

### R Source Code
[Github](`r thisFile`)

```{r knit2synapse, eval=FALSE}
library(synapseClient)
library(knit2synapse) # get the package from devtools::install_github('Sage-Bionetworks/knit2synapse')

synapseLogin()

knit2synapse::knitToFolderEntity(file = "./MAYO_geneLevel_TMM.Rmd",
                                 parentId = "syn8672415",
                                 entityName = 'MAYO Reprocessed RNASeq (TMM Normalised without adjusting for GC and gene length)')
```